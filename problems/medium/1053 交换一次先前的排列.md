#题目描述
给你一个正整数的数组 A（其中的元素不一定完全不同），请你返回可在 一次交换（交换两数字 A[i] 和 A[j] 的位置）后得到的、按字典序排列小于 A 的最大可能排列。

如果无法这么操作，就请返回原数组。

## 示例 1：

输入：[3,2,1]
输出：[3,1,2]
解释：
交换 2 和 1

## 示例 2：

输入：[1,1,5]
输出：[1,1,5]
解释： 
这已经是最小排列

## 示例 3：

输入：[1,9,4,6,7]
输出：[1,7,4,6,9]
解释：
交换 9 和 7

## 示例 4：

输入：[3,1,1,3]
输出：[1,3,1,3]
解释：
交换 1 和 3

## 提示：

1 <= A.length <= 10000
1 <= A[i] <= 10000

# 解题思路

字典序：

在字典中，单词是按照首字母在字母表中的顺序进行排列的，比如 alpha 在 beta 之前。而第一个字母相同时，会去比较两个单词的第二个字母在字母表中的顺序，比如 account 在 advanced 之前，以此类推。

在计算机领域中，这个字典序就不仅仅用来比较英文单词了，而是比较任意字符串。对于两个字符串，大小关系取决于两个字符串从左到右第一个不同字符的 ASCII 值的大小关系。比如`ah1x`小于`ahb`，而`Z5`小于`a3`

## plan 1
逆序查找

```python
class Solution:
    def prevPermOpt1(self, A: List[int]) -> List[int]:
        for i in range(len(A)-1,0,-1):
            if A[i]<A[i-1]:
                for j in range(len(A)-1,i-1,-1):
                    if A[j]<A[i-1] and A[j]!=A[j-1]:
                        A[i-1],A[j] = A[j],A[i-1]
                        return A
        return A

```